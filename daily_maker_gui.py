# -*- coding: utf-8 -*-

"""
Daily Maker with AI (v3.5 - Editable Model Fields)

A desktop application that monitors user activity, analyzes
context with AI, and generates daily reports in a structured format.

Features:
- Editable text fields to define the Gemini models to be used.
- "Always on Top" banner indicating monitoring status and flashes at each capture.
- Button to show/hide the API key.
- Tabbed GUI for easy use.
- Settings saved in a local file (config.json).

Author: Tavares
Version: 3.5
"""

import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox
import schedule
import time
import threading
import base64
import io
import os
import json
import requests
from PIL import ImageGrab
import queue
from functools import partial

# --- Initial Settings ---
CONFIG_FILE = "config.json"
DEFAULT_TEMPLATE = """# Daily Summary ‚Äì [USER_NAME] ‚Äì [DATE]
## Morning Updates:
[MORNING_UPDATES]

## Afternoon Updates:
[AFTERNOON_UPDATES]
"""

# --- Monitoring Banner ---
class MonitoringBanner:
    def __init__(self, root):
        self.root = root
        self.banner = tk.Toplevel(root)
        self.banner.overrideredirect(True) # Remove title bar
        self.banner.geometry("200x30+10+10") # Initial size and position
        self.banner.attributes("-topmost", True) # Always on top
        self.banner.configure(background='black')
        
        self.label = tk.Label(self.banner, text="Monitoring Active...", fg="white", bg="black")
        self.label.pack(side=tk.LEFT, padx=10)
        
        self.minimize_button = tk.Button(self.banner, text="‚Äî", fg="white", bg="black", relief="flat", command=self.minimize)
        self.minimize_button.pack(side=tk.RIGHT, padx=5)

        # Allow window dragging
        self.banner.bind("<Button-1>", self.start_move)
        self.banner.bind("<B1-Motion>", self.do_move)

        self.banner.withdraw() # Start hidden

    def start_move(self, event):
        self.x = event.x
        self.y = event.y

    def do_move(self, event):
        deltax = event.x - self.x
        deltay = event.y - self.y
        x = self.banner.winfo_x() + deltax
        y = self.banner.winfo_y() + deltay
        self.banner.geometry(f"+{x}+{y}")

    def show(self):
        self.banner.deiconify()

    def hide(self):
        self.banner.withdraw()
        
    def minimize(self):
        self.hide()
        # Notify main app to update banner control button
        self.root.show_banner_button.config(state="normal")

    def flash(self):
        original_color = self.banner.cget("background")
        self.banner.configure(background='green')
        self.label.configure(background='green')
        self.banner.after(500, lambda: (
            self.banner.configure(background=original_color),
            self.label.configure(background=original_color)
        ))

# --- Main Application Class ---
class DailyMakerApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Daily Maker with AI v3.5")
        self.root.geometry("700x800")

        # Configuration variables
        self.user_name = tk.StringVar()
        self.api_key = tk.StringVar()
        self.morning_time = tk.StringVar(value="14:00")
        self.afternoon_time = tk.StringVar(value="17:50")
        self.summary_language = tk.StringVar(value="English")
        self.vision_model = tk.StringVar(value="gemini-1.5-flash-latest")
        self.text_model = tk.StringVar(value="gemini-1.5-flash-latest")
        self.monitoring_active = False

        self.log_queue = queue.Queue()
        self.banner = MonitoringBanner(self.root)
        
        self.create_widgets()
        self.load_config()
        self.process_queue()
        
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)

    def on_closing(self):
        self.stop_monitoring()
        self.root.destroy()

    def create_widgets(self):
        self.notebook = ttk.Notebook(self.root)
        self.notebook.pack(expand=True, fill='both', padx=10, pady=10)

        self.summary_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(self.summary_frame, text='Daily Summary')
        self.create_summary_tab()

        self.logs_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(self.logs_frame, text='AI Logs')
        self.create_logs_tab()

        self.config_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(self.config_frame, text='Settings')
        self.create_config_tab()

    def create_summary_tab(self):
        ttk.Label(self.summary_frame, text="Last summary generated by AI (you can edit the text):").pack(pady=(0, 5), anchor="w")
        self.summary_text = scrolledtext.ScrolledText(self.summary_frame, wrap=tk.WORD, height=15)
        self.summary_text.pack(expand=True, fill='both')

    def create_logs_tab(self):
        ttk.Label(self.logs_frame, text="Activities identified by AI in real time:").pack(pady=(0, 5), anchor="w")
        self.logs_text = scrolledtext.ScrolledText(self.logs_frame, wrap=tk.WORD, height=15, state="disabled")
        self.logs_text.pack(expand=True, fill='both')

    def create_config_tab(self):
        frame = ttk.Frame(self.config_frame)
        frame.pack(expand=True, fill='both')

        def add_row(label_text, row):
            ttk.Label(frame, text=label_text).grid(row=row, column=0, padx=5, pady=5, sticky="w")
        
        add_row("Your Name:", 0)
        ttk.Entry(frame, textvariable=self.user_name, width=50).grid(row=0, column=1, padx=5, pady=5, sticky="ew")

        add_row("Gemini API Key:", 1)
        api_frame = ttk.Frame(frame)
        api_frame.grid(row=1, column=1, padx=5, pady=5, sticky="ew")
        self.api_key_entry = ttk.Entry(api_frame, textvariable=self.api_key, width=50, show="*")
        self.api_key_entry.pack(side=tk.LEFT, expand=True, fill='x')
        self.show_key_button = ttk.Button(api_frame, text="üëÅÔ∏è", command=self.toggle_api_key_visibility, width=3)
        self.show_key_button.pack(side=tk.LEFT, padx=(5,0))
        
        add_row("Morning Summary Time (HH:MM):", 2)
        ttk.Entry(frame, textvariable=self.morning_time, width=10).grid(row=2, column=1, padx=5, pady=5, sticky="w")
        
        add_row("Afternoon Summary Time (HH:MM):", 3)
        ttk.Entry(frame, textvariable=self.afternoon_time, width=10).grid(row=3, column=1, padx=5, pady=5, sticky="w")

        add_row("Summary Language:", 4)
        ttk.Combobox(frame, textvariable=self.summary_language, values=['Portuguese', 'English'], state='readonly').grid(row=4, column=1, padx=5, pady=5, sticky="w")

        add_row("Vision Model (for screenshots):", 5)
        ttk.Entry(frame, textvariable=self.vision_model, width=50).grid(row=5, column=1, padx=5, pady=5, sticky="ew")

        add_row("Text Model (for summaries):", 6)
        ttk.Entry(frame, textvariable=self.text_model, width=50).grid(row=6, column=1, padx=5, pady=5, sticky="ew")

        add_row("Daily Template:", 7)
        self.template_text = scrolledtext.ScrolledText(frame, wrap=tk.WORD, height=8)
        self.template_text.grid(row=7, column=1, padx=5, pady=5, sticky="ew")
        
        ttk.Button(frame, text="Save Settings", command=self.save_config).grid(row=8, column=1, padx=5, pady=10, sticky="e")

        controls_frame = ttk.Frame(self.config_frame)
        controls_frame.pack(fill='x', pady=20)
        self.start_button = ttk.Button(controls_frame, text="Start Monitoring", command=self.start_monitoring)
        self.start_button.pack(side="left", padx=5)
        self.stop_button = ttk.Button(controls_frame, text="Stop Monitoring", command=self.stop_monitoring, state="disabled")
        self.stop_button.pack(side="left", padx=5)
        self.show_banner_button = ttk.Button(controls_frame, text="Show Banner", command=self.banner.show, state="disabled")
        self.show_banner_button.pack(side="left", padx=5)

        self.status_label = ttk.Label(self.config_frame, text="Monitoring: INACTIVE", foreground="red")
        self.status_label.pack(pady=10)

    def toggle_api_key_visibility(self):
        if self.api_key_entry.cget('show') == '*':
            self.api_key_entry.config(show='')
        else:
            self.api_key_entry.config(show='*')

    def load_config(self):
        try:
            with open(CONFIG_FILE, 'r') as f:
                config = json.load(f)
                self.user_name.set(config.get("user_name", ""))
                self.api_key.set(config.get("api_key", ""))
                self.morning_time.set(config.get("morning_time", "14:00"))
                self.afternoon_time.set(config.get("afternoon_time", "17:50"))
                self.summary_language.set(config.get("summary_language", "English"))
                self.vision_model.set(config.get("vision_model", "gemini-1.5-flash-latest"))
                self.text_model.set(config.get("text_model", "gemini-1.5-flash-latest"))
                template = config.get("daily_template", DEFAULT_TEMPLATE)
                self.template_text.delete('1.0', tk.END)
                self.template_text.insert('1.0', template)
        except (FileNotFoundError, json.JSONDecodeError):
            self.template_text.insert('1.0', DEFAULT_TEMPLATE)

    def save_config(self):
        config = {
            "user_name": self.user_name.get(), "api_key": self.api_key.get(),
            "morning_time": self.morning_time.get(), "afternoon_time": self.afternoon_time.get(),
            "summary_language": self.summary_language.get(),
            "vision_model": self.vision_model.get(), "text_model": self.text_model.get(),
            "daily_template": self.template_text.get('1.0', tk.END).strip()
        }
        with open(CONFIG_FILE, 'w') as f:
            json.dump(config, f, indent=4)
        messagebox.showinfo("Success", "Settings saved!\n\nRestart monitoring for new schedule or model settings to take effect.")

    def start_monitoring(self):
        if not self.api_key.get() or not self.user_name.get():
            messagebox.showerror("Error", "Please fill in your name and API key before starting.")
            return
        
        self.monitoring_active = True
        self.status_label.config(text="Monitoring: ACTIVE", foreground="green")
        self.start_button.config(state="disabled")
        self.stop_button.config(state="normal")
        self.show_banner_button.config(state="disabled")
        self.banner.show()
        
        self.monitor_thread = threading.Thread(target=run_monitoring_logic, args=(self.log_queue, self.get_current_config, lambda: self.monitoring_active), daemon=True)
        self.monitor_thread.start()
        self.add_log("Monitoring started.")

    def stop_monitoring(self):
        if not self.monitoring_active: return
        self.monitoring_active = False
        self.status_label.config(text="Monitoring: INACTIVE", foreground="red")
        self.start_button.config(state="normal")
        self.stop_button.config(state="disabled")
        self.show_banner_button.config(state="disabled")
        self.banner.hide()
        self.add_log("Monitoring stopped.")

    def add_log(self, message):
        log_entry = f"[{time.strftime('%H:%M:%S')}] {message}\n"
        self.logs_text.config(state="normal")
        self.logs_text.insert(tk.END, log_entry)
        self.logs_text.see(tk.END)
        self.logs_text.config(state="disabled")

    def display_summary(self, summary):
        self.summary_text.delete('1.0', tk.END)
        self.summary_text.insert(tk.END, summary)
        self.notebook.select(self.summary_frame)

    def process_queue(self):
        try:
            message_type, data = self.log_queue.get_nowait()
            if message_type == "log": self.add_log(data)
            elif message_type == "summary": self.display_summary(data)
            elif message_type == "flash": self.banner.flash()
        except queue.Empty:
            pass
        finally:
            self.root.after(100, self.process_queue)

    def get_current_config(self):
        return {k: v.get() for k, v in {
            "user_name": self.user_name, "api_key": self.api_key,
            "morning_time": self.morning_time, "afternoon_time": self.afternoon_time,
            "summary_language": self.summary_language,
            "vision_model": self.vision_model, "text_model": self.text_model
        }.items()} | {"daily_template": self.template_text.get('1.0', tk.END)}

# --- Monitoring Logic ---
def run_monitoring_logic(log_queue, config_provider, is_active_checker):
    config = config_provider()
    CAPTURE_INTERVAL_MINUTES = 5
    GEMINI_API_URL_BASE = "https://generativelanguage.googleapis.com/v1beta/models/"
    registered_activities = []
    generated_morning_template = ""
    
    log_queue.put(("log", f"Scheduler set for {config['morning_time']} and {config['afternoon_time']}."))

    def call_gemini_api(model, payload, api_key):
        url = f"{GEMINI_API_URL_BASE}{model}:generateContent?key={api_key}"
        try:
            response = requests.post(url, headers={'Content-Type': 'application/json'}, data=json.dumps(payload), timeout=60)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            log_queue.put(("log", f"API ERROR: {e}"))
            return None

    def analyze_screenshot():
        current_config = config_provider()
        try:
            screenshot = ImageGrab.grab()
            temp_path = "temp_screenshot.png"
            screenshot.save(temp_path)
            log_queue.put(("flash", None))
            log_queue.put(("log", "Analyzing screenshot..."))

            with open(temp_path, "rb") as image_file:
                encoded_string = base64.b64encode(image_file.read()).decode('utf-8')
            
            prompt = "Analyze this screenshot. Describe the main activity in a short and objective sentence. Focus on work tasks (development, communication, etc.)."
            payload = {"contents": [{"parts": [{"text": prompt}, {"inline_data": {"mime_type": "image/png", "data": encoded_string}}]}]}
            result = call_gemini_api(current_config['vision_model'], payload, current_config['api_key'])

            if result and 'candidates' in result:
                description = result['candidates'][0]['content']['parts'][0]['text'].strip()
                log_queue.put(("log", f"AI Described: {description}"))
                if "could not" not in description.lower():
                    registered_activities.append(f"- {time.strftime('%H:%M')}: {description}")
            os.remove(temp_path)
        except Exception as e:
            log_queue.put(("log", f"CAPTURE ERROR: {e}"))

    def generate_summary(summary_type):
        nonlocal generated_morning_template
        current_config = config_provider()
        log_queue.put(("log", f"Generating summary ({summary_type})..."))
        
        if not registered_activities:
            log_queue.put(("log", "No activities to summarize."))
            return
            
        activities_str = '\n'.join(registered_activities)
        prompt_ai = f"""Based on the following list of activities, generate a concise summary in 2 or 3 bullet points (using '- '). Group similar tasks. IMPORTANT: Generate the summary in the following language: {current_config['summary_language']}. Activities: {activities_str}"""
        
        payload = {"contents": [{"parts": [{"text": prompt_ai}]}]}
        result = call_gemini_api(current_config['text_model'], payload, current_config['api_key'])
        ai_summary = "Could not generate summary by AI."

        if result and 'candidates' in result:
            ai_summary = result['candidates'][0]['content']['parts'][0]['text']

        today_str = time.strftime("%a, %d/%m/%Y")
        if summary_type == "Morning":
            temp_summary = current_config['daily_template'].replace("[USER_NAME]", current_config['user_name']).replace("[DATE]", today_str).replace("[MORNING_UPDATES]", ai_summary)
            generated_morning_template = temp_summary
            log_queue.put(("summary", generated_morning_template))
        elif summary_type == "Afternoon":
            final_summary = (generated_morning_template or current_config['daily_template']).replace("[AFTERNOON_UPDATES]", ai_summary)
            if not generated_morning_template:
                 final_summary = final_summary.replace("[USER_NAME]", current_config['user_name']).replace("[DATE]", today_str).replace("[MORNING_UPDATES]", "No activities registered in the morning period.")
            log_queue.put(("summary", final_summary))
            generated_morning_template = ""
        registered_activities.clear()

    schedule.every(CAPTURE_INTERVAL_MINUTES).minutes.do(analyze_screenshot)
    schedule.every().day.at(config['morning_time']).do(partial(generate_summary, summary_type="Morning"))
    schedule.every().day.at(config['afternoon_time']).do(partial(generate_summary, summary_type="Afternoon"))
    
    analyze_screenshot() # First immediate capture

    while is_active_checker():
        schedule.run_pending()
        time.sleep(1)

if __name__ == "__main__":
    root = tk.Tk()
    app = DailyMakerApp(root)
    root.mainloop()